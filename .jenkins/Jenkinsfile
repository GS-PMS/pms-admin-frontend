pipeline {
    agent any

    environment {
        DOCKER_HUB_REPO = 'salmawaleedd'
        SERVICE_NAME = 'pms-admin-frontend'
        IMAGE_TAG = "${BUILD_NUMBER}"
        SWARM_SERVICE_NAME = 'admin-frontend'
        HEALTH_CHECK_PORT = '4200'
        COMPOSE_FILE = 'docker-compose-admin.yml'
    }

    // ============================================
    // STAGE 1: VALIDATE PUSH METHOD
    // ============================================
    stage('ğŸš¨ Validate Push Method') {
        steps {
            script {
                echo "=== Validating Git workflow ==="
                
                def isMerge = sh(
                    script: "git rev-parse HEAD^2 >/dev/null 2>&1 && echo true || echo false",
                    returnStdout: true
                ).trim()

                def committer = sh(
                    script: "git log -1 --pretty=format:%cn",
                    returnStdout: true
                ).trim()

                if (isMerge == "false") {
                    error """
                    âŒâŒâŒ DIRECT PUSH TO MAIN BLOCKED âŒâŒâŒ
                    Commit ${env.GIT_COMMIT} by ${committer} is a direct commit to main.
                    
                    ğŸ“‹ REQUIRED WORKFLOW:
                    1. Create feature branch: git checkout -b feature/your-feature
                    2. Make changes and commit
                    3. Create Pull Request to main
                    4. Get code review approval
                    5. Merge via PR (creates merge commit)
                    """
                } else {
                    echo "âœ… Merge commit detected â€” committer: ${committer}"
                    echo "âœ… PR workflow followed correctly"
                }
            }
        }
    }

    // ============================================
    // STAGE 2: ENVIRONMENT CHECK
    // ============================================
    stage('ğŸ”§ Environment Check') {
        steps {
            script {
                echo "=== Checking build environment ==="
                
                sh '''
                    echo "ğŸ“¦ Required tools:"
                    docker --version || { echo "âŒ Docker not found"; exit 1; }
                    node --version || { echo "âŒ Node.js not found"; exit 1; }
                    npm --version || { echo "âŒ npm not found"; exit 1; }
                    git --version || { echo "âŒ Git not found"; exit 1; }
                    which curl || { echo "âŒ curl not found"; exit 1; }
                    
                    echo "âœ… All required tools available"
                    
                    FREE_SPACE=\$(df -h . | awk 'NR==2 {print \$4}' | sed 's/G//')
                    if [ \$FREE_SPACE -lt 1 ]; then
                        echo "âš ï¸  Low disk space: \${FREE_SPACE}G free"
                    fi
                '''
                
                echo "âœ… Environment check passed"
            }
        }
    }

    // ============================================
    // STAGE 3: CHECKOUT CODE
    // ============================================
    stage('ğŸ“¥ Checkout Code') {
        steps {
            echo "=== Checking out ${SERVICE_NAME} ==="
            checkout scm
            
            echo "âœ… Repository: ${env.GIT_URL}"
            echo "âœ… Branch: ${env.GIT_BRANCH}"
            echo "âœ… Commit: ${env.GIT_COMMIT}"
        }
    }

    // ============================================
    // STAGE 4: INSTALL DEPENDENCIES
    // ============================================
    stage('ğŸ“¦ Install Dependencies') {
        steps {
            echo "=== Installing npm dependencies ==="
            
            sh 'npm ci'
            
            echo "âœ… Dependencies installed successfully"
            
            script {
                def nodeModulesSize = sh(
                    script: 'du -sh node_modules | cut -f1',
                    returnStdout: true
                ).trim()
                
                echo "ğŸ“Š Node modules size: ${nodeModulesSize}"
            }
        }
    }

    // ============================================
    // STAGE 5: BUILD APPLICATION
    // ============================================
    stage('ğŸ—ï¸ Build Application') {
        steps {
            echo "=== Building ${SERVICE_NAME} ==="
            
            sh 'npm run build'
            
            echo "âœ… Angular build completed"
            
            script {
                def buildSize = sh(
                    script: 'du -sh dist/ | cut -f1',
                    returnStdout: true
                ).trim()
                
                echo "ğŸ“Š Build output size: ${buildSize}"
            }
        }
    }

    // ============================================
    // STAGE 6: BUILD DOCKER IMAGE
    // ============================================
    stage('ğŸ³ Build Docker Image') {
        steps {
            script {
                echo "=== Building Docker image ==="
                
                sh """
                    docker build -t ${DOCKER_HUB_REPO}/${SERVICE_NAME}:${IMAGE_TAG} .
                    docker tag ${DOCKER_HUB_REPO}/${SERVICE_NAME}:${IMAGE_TAG} ${DOCKER_HUB_REPO}/${SERVICE_NAME}:latest
                """
                
                echo "âœ… Docker image built successfully"
                echo "ğŸ“¦ Image: ${DOCKER_HUB_REPO}/${SERVICE_NAME}:${IMAGE_TAG}"
                echo "ğŸ“¦ Also tagged as: ${DOCKER_HUB_REPO}/${SERVICE_NAME}:latest"
            }
        }
    }

    // ============================================
    // STAGE 7: PUSH TO DOCKER HUB
    // ============================================
    stage('ğŸ“¤ Push to Docker Hub') {
        steps {
            script {
                echo "=== Pushing to Docker Hub ==="
                
                withCredentials([usernamePassword(
                    credentialsId: 'dockerhub-credentials',
                    usernameVariable: 'DOCKER_USER',
                    passwordVariable: 'DOCKER_PASS'
                )]) {
                    sh """
                        echo "ğŸ” Logging in to Docker Hub as \${DOCKER_USER}"
                        echo \$DOCKER_PASS | docker login -u \$DOCKER_USER --password-stdin
                        
                        echo "ğŸ“¤ Pushing image with build tag..."
                        docker push ${DOCKER_HUB_REPO}/${SERVICE_NAME}:${IMAGE_TAG}
                        
                        echo "ğŸ“¤ Pushing 'latest' tag..."
                        docker push ${DOCKER_HUB_REPO}/${SERVICE_NAME}:latest
                    """
                }
                
                echo "âœ… Images pushed to Docker Hub successfully"
                echo "ğŸŒ Available at: https://hub.docker.com/r/${DOCKER_HUB_REPO}/${SERVICE_NAME}"
            }
        }
    }

    // ============================================
    // STAGE 8: AUTO-CONFIGURE DOCKER SWARM
    // ============================================
    stage('ğŸ” Auto-Configure Docker Swarm') {
        steps {
            script {
                echo "=== Auto-configuring Docker Swarm ==="
                
                // 1. Auto-initialize Swarm if not active
                def swarmActive = sh(
                    script: "docker info --format '{{.Swarm.LocalNodeState}}' 2>/dev/null || echo 'inactive'",
                    returnStdout: true
                ).trim()
                
                if (swarmActive != 'active') {
                    echo "ğŸ”„ Docker Swarm is not active - initializing..."
                    try {
                        sh '''
                            docker swarm init --advertise-addr 127.0.0.1 2>/dev/null || \
                            docker swarm join-token manager 2>/dev/null || \
                            echo "Swarm initialization may have failed"
                        '''
                        sleep 3
                        
                        // Verify Swarm is now active
                        swarmActive = sh(
                            script: "docker info --format '{{.Swarm.LocalNodeState}}'",
                            returnStdout: true
                        ).trim()
                        
                        if (swarmActive == 'active') {
                            echo "âœ… Docker Swarm initialized successfully"
                        } else {
                            echo "âš ï¸  Could not verify Swarm initialization"
                        }
                    } catch (Exception e) {
                        echo "âš ï¸  Swarm initialization attempt failed: ${e.message}"
                    }
                } else {
                    echo "âœ… Docker Swarm is already active"
                }
                
                // 2. Check if service exists
                def serviceExists = sh(
                    script: "docker service ls --filter name=${SWARM_SERVICE_NAME} --format '{{.Name}}' 2>/dev/null || echo 'not-found'",
                    returnStdout: true
                ).trim()
                
                if (serviceExists == 'not-found') {
                    echo "âš ï¸  Service '${SWARM_SERVICE_NAME}' not found - creating it..."
                    
                    // Check if COMPOSE_FILE exists
                    def composeFileExists = sh(
                        script: "test -f ${COMPOSE_FILE} && echo 'exists' || echo 'not-found'",
                        returnStdout: true
                    ).trim()
                    
                    if (composeFileExists == 'exists') {
                        // Use the compose file to create service
                        echo "ğŸ“¦ Creating service from ${COMPOSE_FILE}..."
                        sh """
                            docker stack deploy -c ${COMPOSE_FILE} pms-admin
                            sleep 10
                            echo "âœ… Service created from ${COMPOSE_FILE}"
                        """
                    } else {
                        error """
                        âŒ COMPOSE FILE NOT FOUND: ${COMPOSE_FILE}
                        
                        ğŸ“‹ You need to create '${COMPOSE_FILE}' with this content:
                        
                        version: '3.8'
                        services:
                          ${SWARM_SERVICE_NAME}:
                            image: ${DOCKER_HUB_REPO}/${SERVICE_NAME}:latest
                            ports:
                              - "${HEALTH_CHECK_PORT}:80"
                            deploy:
                              replicas: 2
                              restart_policy:
                                condition: on-failure
                        
                        ğŸ’¡ Create the file with this command:
                        cat > ${COMPOSE_FILE} << 'EOF'
                        version: '3.8'
                        services:
                          ${SWARM_SERVICE_NAME}:
                            image: ${DOCKER_HUB_REPO}/${SERVICE_NAME}:latest
                            ports:
                              - "${HEALTH_CHECK_PORT}:80"
                            deploy:
                              replicas: 2
                              restart_policy:
                                condition: on-failure
                        EOF
                        
                        Then run this pipeline again.
                        """
                    }
                    
                    // Verify service was created
                    sleep 5
                    serviceExists = sh(
                        script: "docker service ls --filter name=${SWARM_SERVICE_NAME} --format '{{.Name}}' 2>/dev/null || echo 'not-found'",
                        returnStdout: true
                    ).trim()
                    
                    if (serviceExists == 'not-found') {
                        // Try alternative naming (Docker adds stack prefix)
                        def stackServiceName = "pms-admin_${SWARM_SERVICE_NAME}"
                        serviceExists = sh(
                            script: "docker service ls --filter name=${stackServiceName} --format '{{.Name}}' 2>/dev/null || echo 'not-found'",
                            returnStdout: true
                        ).trim()
                        
                        if (serviceExists != 'not-found') {
                            echo "â„¹ï¸  Found service with stack prefix: ${serviceExists}"
                            env.SWARM_SERVICE_NAME = serviceExists
                        } else {
                            // Last resort: create service directly
                            echo "âš ï¸  Stack deployment didn't create service - creating directly..."
                            sh """
                                docker service create \\
                                    --name ${SWARM_SERVICE_NAME} \\
                                    --publish ${HEALTH_CHECK_PORT}:80 \\
                                    --replicas 2 \\
                                    --restart-condition on-failure \\
                                    ${DOCKER_HUB_REPO}/${SERVICE_NAME}:latest
                            """
                            sleep 10
                        }
                    }
                }
                
                // 3. Verify service exists now
                def finalServiceExists = sh(
                    script: "docker service ls --filter name=${SWARM_SERVICE_NAME} --format '{{.Name}}' 2>/dev/null || echo 'not-found'",
                    returnStdout: true
                ).trim()
                
                if (finalServiceExists == 'not-found') {
                    // Check for any service with similar name
                    def allServices = sh(
                        script: "docker service ls --format '{{.Name}}'",
                        returnStdout: true
                    ).trim()
                    
                    echo "ğŸ” Searching for existing services:"
                    echo "${allServices}"
                    
                    // Try to find our service with variations
                    def foundService = allServices.split('\n').find { it.contains('admin') || it.contains(SERVICE_NAME) }
                    
                    if (foundService) {
                        echo "â„¹ï¸  Found similar service: ${foundService}"
                        echo "Updating SWARM_SERVICE_NAME to: ${foundService}"
                        env.SWARM_SERVICE_NAME = foundService
                    } else {
                        error """
                        âŒ SERVICE CREATION FAILED
                        
                        Service '${SWARM_SERVICE_NAME}' could not be created.
                        
                        ğŸ”§ MANUAL CREATION REQUIRED:
                        
                        OPTION 1: Create compose file and deploy:
                        echo 'version: "3.8"
                        services:
                          ${SWARM_SERVICE_NAME}:
                            image: ${DOCKER_HUB_REPO}/${SERVICE_NAME}:latest
                            ports:
                              - "${HEALTH_CHECK_PORT}:80"
                            deploy:
                              replicas: 2' > ${COMPOSE_FILE}
                        
                        docker stack deploy -c ${COMPOSE_FILE} pms-admin
                        
                        OPTION 2: Create service directly:
                        docker service create \\
                          --name ${SWARM_SERVICE_NAME} \\
                          --publish ${HEALTH_CHECK_PORT}:80 \\
                          --replicas 2 \\
                          ${DOCKER_HUB_REPO}/${SERVICE_NAME}:latest
                        
                        Then run this pipeline again.
                        """
                    }
                }
                
                // 4. Get service details
                echo "âœ… Service '${SWARM_SERVICE_NAME}' is ready"
                sh """
                    echo "ğŸ“Š Service details:"
                    docker service ls --filter name=${SWARM_SERVICE_NAME} --format '
Name:     {{.Name}}
Image:    {{.Image}}
Replicas: {{.Replicas}}
Ports:    {{.Ports}}
                    '
                    
                    echo ""
                    echo "ğŸ“ˆ Current status:"
                    docker service ps ${SWARM_SERVICE_NAME} --format 'table {{.Name}}\\t{{.CurrentState}}\\t{{.Node}}' --no-trunc | head -10
                """
                
                echo "âœ… All pre-deployment checks completed successfully"
            }
        }
    }

    // ============================================
    // STAGE 9: DEPLOY TO DOCKER SWARM
    // ============================================
    stage('ğŸš€ Deploy to Docker Swarm') {
        steps {
            script {
                echo "=== Deploying ${SERVICE_NAME} to Docker Swarm ==="
                
                echo "ğŸ“¦ New image: ${DOCKER_HUB_REPO}/${SERVICE_NAME}:${IMAGE_TAG}"
                echo "ğŸ¯ Target service: ${SWARM_SERVICE_NAME}"
                echo "ğŸ·ï¸  Updating from current to new image..."
                
                // Get current image for comparison
                def currentImage = sh(
                    script: """
                        docker service inspect ${SWARM_SERVICE_NAME} \
                            --format '{{.Spec.TaskTemplate.ContainerSpec.Image}}' 2>/dev/null || echo 'unknown'
                    """,
                    returnStdout: true
                ).trim()
                
                echo "ğŸ”„ Current image: ${currentImage}"
                echo "ğŸ†• New image: ${DOCKER_HUB_REPO}/${SERVICE_NAME}:${IMAGE_TAG}"
                
                if (currentImage == "${DOCKER_HUB_REPO}/${SERVICE_NAME}:${IMAGE_TAG}") {
                    echo "âš ï¸  Service already running the same image version"
                    echo "Skipping update - nothing to deploy"
                } else {
                    // Update the service with controlled rollout
                    sh """
                        docker service update \
                            --image ${DOCKER_HUB_REPO}/${SERVICE_NAME}:${IMAGE_TAG} \
                            --update-parallelism 1 \
                            --update-delay 10s \
                            --update-failure-action rollback \
                            --update-monitor 30s \
                            --update-order start-first \
                            --with-registry-auth \
                            ${SWARM_SERVICE_NAME}
                    """
                    
                    echo "ğŸ”„ Rolling update initiated"
                    echo "ğŸ“‹ Update strategy:"
                    echo "   â€¢ Parallelism: 1 (one container at a time)"
                    echo "   â€¢ Delay: 10s (between updates)"
                    echo "   â€¢ Failure action: rollback"
                    echo "   â€¢ Order: start-first (new before old)"
                    echo "   â€¢ Auth: with-registry-auth (pulls private images)"
                }
            }
        }
    }

    // ============================================
    // STAGE 10: MONITOR DEPLOYMENT
    // ============================================
    stage('ğŸ‘€ Monitor Deployment') {
        steps {
            script {
                echo "=== Monitoring deployment progress ==="
                
                def maxWaitTime = 300  // 5 minutes
                def startTime = System.currentTimeMillis()
                def updateCompleted = false
                def rollbackDetected = false
                
                while (System.currentTimeMillis() - startTime < maxWaitTime * 1000) {
                    // 1. Check update status
                    def updateStatus = sh(
                        script: """
                            docker service inspect ${SWARM_SERVICE_NAME} \
                                --format '{{.UpdateStatus.State}}' 2>/dev/null || echo 'unknown'
                        """,
                        returnStdout: true
                    ).trim()
                    
                    // 2. Check replica status
                    def replicaStatus = sh(
                        script: "docker service ls --filter name=${SWARM_SERVICE_NAME} --format '{{.Replicas}}' 2>/dev/null || echo '0/0'",
                        returnStdout: true
                    ).trim()
                    
                    // 3. Check current image (verify update took effect)
                    def currentImage = sh(
                        script: """
                            docker service inspect ${SWARM_SERVICE_NAME} \
                                --format '{{.Spec.TaskTemplate.ContainerSpec.Image}}' 2>/dev/null || echo 'unknown'
                        """,
                        returnStdout: true
                    ).trim()
                    
                    echo "ğŸ“Š Status update:"
                    echo "   Update state: ${updateStatus}"
                    echo "   Replicas: ${replicaStatus}"
                    echo "   Current image: ${currentImage}"
                    
                    // Check for rollback
                    if (updateStatus == 'rollback_completed') {
                        rollbackDetected = true
                        error "âŒ DEPLOYMENT FAILED - Service was rolled back!"
                    }
                    
                    if (updateStatus == 'rollback_started' || updateStatus == 'paused') {
                        echo "âš ï¸  Update is rolling back..."
                        rollbackDetected = true
                    }
                    
                    // Check for completion
                    def allRunning = false
                    if (replicaStatus.contains('/')) {
                        def parts = replicaStatus.split('/')
                        def running = parts[0].toInteger()
                        def total = parts[1].toInteger()
                        allRunning = (running == total)
                    }
                    
                    def updateComplete = (updateStatus == 'completed' || updateStatus == '' || updateStatus == 'unknown')
                    
                    if (allRunning && updateComplete) {
                        updateCompleted = true
                        break
                    }
                    
                    sleep 10  // Wait 10 seconds between checks
                }
                
                if (rollbackDetected) {
                    error "âŒ Deployment failed - service was rolled back to previous version"
                }
                
                if (!updateCompleted) {
                    echo "âš ï¸  Deployment taking longer than expected"
                    echo "Checking container status..."
                    sh "docker service ps ${SWARM_SERVICE_NAME} --no-trunc"
                    
                    // Final check - are containers running?
                    def finalReplicas = sh(
                        script: "docker service ls --filter name=${SWARM_SERVICE_NAME} --format '{{.Replicas}}'",
                        returnStdout: true
                    ).trim()
                    
                    if (finalReplicas.contains('/')) {
                        def parts = finalReplicas.split('/')
                        def running = parts[0].toInteger()
                        def total = parts[1].toInteger()
                        
                        if (running == total) {
                            echo "âœ… All replicas running, considering deployment successful"
                            updateCompleted = true
                        } else {
                            echo "âš ï¸  Only ${running}/${total} replicas running"
                        }
                    }
                }
                
                if (updateCompleted) {
                    echo "âœ… Deployment monitoring completed successfully"
                } else {
                    error "âŒ Deployment monitoring timeout - check service manually"
                }
            }
        }
    }

    // ============================================
    // STAGE 11: HEALTH CHECK
    // ============================================
    stage('ğŸ¥ Health Check') {
        steps {
            script {
                echo "=== Performing health checks ==="
                
                // Get the actual published port from the service
                def publishedPort = sh(
                    script: """
                        docker service inspect ${SWARM_SERVICE_NAME} \
                            --format '{{(index .Endpoint.Ports 0).PublishedPort}}' 2>/dev/null || echo '${HEALTH_CHECK_PORT}'
                    """,
                    returnStdout: true
                ).trim()
                
                echo "ğŸ”Œ Testing service on port: ${publishedPort}"
                
                def healthCheckPassed = false
                def maxAttempts = 6  // 1 minute total with 10s intervals
                
                for (int attempt = 1; attempt <= maxAttempts; attempt++) {
                    echo "ğŸ©º Health check attempt ${attempt}/${maxAttempts}"
                    
                    try {
                        // Try to access the service
                        def statusCode = sh(
                            script: """
                                curl -s -o /dev/null -w '%{http_code}' \
                                    --max-time 5 \
                                    http://localhost:${publishedPort} || echo '000'
                            """,
                            returnStdout: true
                        ).trim()
                        
                        if (statusCode == '200' || statusCode.startsWith('2')) {
                            echo "âœ… Health check PASSED (HTTP ${statusCode})"
                            healthCheckPassed = true
                            
                            // Additional verification - get page title
                            def pageTitle = sh(
                                script: """
                                    curl -s --max-time 5 http://localhost:${publishedPort} | \
                                    grep -o '<title>[^<]*</title>' | \
                                    sed 's/<title>\\(.*\\)<\\/title>/\\1/' || echo 'Unknown'
                                """,
                                returnStdout: true
                            ).trim()
                            
                            echo "ğŸ“„ Page title: ${pageTitle}"
                            break
                        } else {
                            echo "â³ Got HTTP ${statusCode}, retrying in 10s..."
                        }
                    } catch (Exception e) {
                        echo "â³ Connection failed: ${e.message}, retrying in 10s..."
                    }
                    
                    sleep 10
                }
                
                if (!healthCheckPassed) {
                    echo "âš ï¸  Health check inconclusive - checking container logs"
                    
                    // Fallback: check if containers are running
                    sh """
                        echo "ğŸ“‹ Container status:"
                        docker service ps ${SWARM_SERVICE_NAME} \
                            --format 'table {{.Name}}\\t{{.CurrentState}}\\t{{.Error}}' \
                            --no-trunc \
                            --filter 'desired-state=running'
                        
                        echo ""
                        echo "ğŸ“œ Recent logs:"
                        docker service logs ${SWARM_SERVICE_NAME} --tail 5 2>/dev/null || echo "Could not retrieve logs"
                    """
                    
                    // Don't fail the pipeline - just warn
                    echo "âš ï¸  Health check didn't pass, but containers appear to be running"
                    echo "âš ï¸  Manual verification recommended"
                }
            }
        }
    }

    // ============================================
    // STAGE 12: POST-DEPLOYMENT VERIFICATION
    // ============================================
    stage('ğŸ“Š Post-Deployment Verification') {
        steps {
            script {
                echo "=== Verifying deployment ==="
                
                // 1. Final service status
                sh """
                    echo "ğŸ¯ FINAL SERVICE STATUS:"
                    docker service ls --filter name=${SWARM_SERVICE_NAME} --format '
Name:     {{.Name}}
Image:    {{.Image}}
Replicas: {{.Replicas}}
Port:    {{range .Ports}}{{.PublishedPort}}->{{.TargetPort}} {{end}}
                    '
                    
                    echo ""
                    echo "ğŸ“¦ RUNNING CONTAINERS:"
                    docker service ps ${SWARM_SERVICE_NAME} \
                        --format 'table {{.Name}}\\t{{.CurrentState}}\\t{{.Node}}' \
                        --filter 'desired-state=running'
                """
                
                // 2. Verify all replicas are running
                def finalReplicas = sh(
                    script: "docker service ls --filter name=${SWARM_SERVICE_NAME} --format '{{.Replicas}}'",
                    returnStdout: true
                ).trim()
                
                if (finalReplicas.contains('/')) {
                    def parts = finalReplicas.split('/')
                    def running = parts[0].toInteger()
                    def desired = parts[1].toInteger()
                    
                    if (running == desired) {
                        echo "âœ… SUCCESS: All ${desired} replicas running"
                    } else {
                        echo "âš ï¸  WARNING: ${running}/${desired} replicas running"
                        echo "   Containers may still be starting up"
                    }
                }
                
                // 3. Deployment summary
                def currentImage = sh(
                    script: "docker service ls --filter name=${SWARM_SERVICE_NAME} --format '{{.Image}}'",
                    returnStdout: true
                ).trim()
                
                echo """
                ğŸ“‹ DEPLOYMENT COMPLETE:
                â€¢ Service: ${SWARM_SERVICE_NAME}
                â€¢ New Image: ${currentImage}
                â€¢ Access: http://localhost:${publishedPort ?: HEALTH_CHECK_PORT}
                â€¢ Replicas: ${finalReplicas}
                â€¢ Build: ${IMAGE_TAG}
                
                ğŸ”§ MANAGEMENT COMMANDS:
                View logs:    docker service logs ${SWARM_SERVICE_NAME} -f
                Check status: docker service ps ${SWARM_SERVICE_NAME}
                Scale up:     docker service scale ${SWARM_SERVICE_NAME}=3
                Rollback:     docker service rollback ${SWARM_SERVICE_NAME}
                """
            }
        }
    }

    // ============================================
    // POST-BUILD ACTIONS
    // ============================================
    post {
        always {
            echo "=== Cleaning up ==="
            sh '''
                echo "ğŸ§¹ Cleaning Docker resources..."
                docker logout 2>/dev/null || true
                docker image prune -f 2>/dev/null || true
                echo "âœ… Cleanup completed"
            '''
        }

        success {
            script {
                def publishedPort = sh(
                    script: """
                        docker service inspect ${SWARM_SERVICE_NAME} \
                            --format '{{(index .Endpoint.Ports 0).PublishedPort}}' 2>/dev/null || echo '${HEALTH_CHECK_PORT}'
                    """,
                    returnStdout: true
                ).trim()
                
                echo """
                ğŸ‰ğŸ‰ğŸ‰ PIPELINE SUCCESSFUL! ğŸ‰ğŸ‰ğŸ‰
                
                âœ… ${SERVICE_NAME} deployed successfully
                ğŸ“¦ Version: ${IMAGE_TAG}
                ğŸ³ Image: ${DOCKER_HUB_REPO}/${SERVICE_NAME}:${IMAGE_TAG}
                ğŸ Service: ${SWARM_SERVICE_NAME}
                ğŸŒ Access: http://localhost:${publishedPort}
                
                ğŸ“Š Next steps:
                1. Test the application manually
                2. Monitor for any issues
                3. Update documentation if needed
                
                ğŸ› ï¸  Troubleshooting:
                docker service logs ${SWARM_SERVICE_NAME} -f
                docker service ps ${SWARM_SERVICE_NAME}
                """
            }
        }

        failure {
            echo """
            âŒâŒâŒ PIPELINE FAILED âŒâŒâŒ
            
            ğŸ” Investigation steps:
            1. Check Jenkins console output above
            2. Check Docker Swarm service: docker service ps ${SWARM_SERVICE_NAME}
            3. Check container logs: docker service logs ${SWARM_SERVICE_NAME}
            4. Check if image exists: docker image ls | grep ${SERVICE_NAME}
            
            ğŸ› ï¸  Recovery actions:
            â€¢ Rollback: docker service rollback ${SWARM_SERVICE_NAME}
            â€¢ Redeploy previous version manually
            â€¢ Check Docker Swarm status: docker node ls
            """
        }

        unstable {
            echo "âš ï¸  Pipeline marked as unstable - check test results or warnings"
        }

        changed {
            echo "ğŸ“ˆ Pipeline status changed from previous build"
        }
    }
}
