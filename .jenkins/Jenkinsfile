// ============================================
// COMPLETE JENKINS PIPELINE - SINGLE FILE
// ============================================

node {
    // ============================================
    // CONFIGURATION
    // ============================================
    def config = [
        docker: [
            credentialsId: 'dockerhub-credentials',
            repo: 'salmawaleedd',
            latestTag: 'latest'
        ],
        
        application: [
            name: 'pms-admin-frontend',
            installCommand: 'npm ci',
            buildCommand: 'npm run build',
            containerPort: '80',
            healthCheckPath: '/'
        ],
        
        deployment: [
            stackName: 'pms-admin',
            composeServiceName: 'admin-frontend',
            composeFile: 'docker-compose-admin.yml',
            hostPort: '4200',
            replicas: 2,
            updateParallelism: 1,
            updateDelay: '10s',
            updateOrder: 'start-first'
        ],
        
        pipeline: [
            buildTimeout: 30,  // minutes
            deployTimeout: 300, // seconds
            healthCheckAttempts: 10,
            healthCheckInterval: 5, // seconds
            maxRetries: 2,
            pruneImages: true
        ],
        
        validation: [
            minDiskSpace: 1,
            requiredTools: ['docker', 'node', 'npm', 'git'],
            blockDirectPushes: true
        ]
    ]
    
    // ============================================
    // DERIVED VALUES
    // ============================================
    def derived = [
        imageTag: "${config.docker.repo}/${config.application.name}:${BUILD_NUMBER}",
        latestTag: "${config.docker.repo}/${config.application.name}:latest",
        swarmServiceName: "${config.deployment.stackName}_${config.deployment.composeServiceName}",
        buildInfo: [
            number: BUILD_NUMBER,
            tag: BUILD_TAG,
            url: BUILD_URL
        ]
    ]
    
    // ============================================
    // PIPELINE EXECUTION
    // ============================================
    try {
        timeout(time: config.pipeline.buildTimeout, unit: 'MINUTES') {
            pipelineStages(config, derived)
        }
        currentBuild.result = 'SUCCESS'
    } catch (Exception e) {
        currentBuild.result = 'FAILURE'
        handleFailure(e, config, derived)
        throw e
    } finally {
        cleanup(config)
        displaySummary(currentBuild.result, config, derived)
    }
}

// ============================================
// PIPELINE STAGES
// ============================================

def pipelineStages(config, derived) {
    stage('üö® Validate Git Workflow') {
        validateGitWorkflow(config)
    }
    
    stage('üîß Environment Check') {
        environmentCheck(config)
    }
    
    stage('üì• Checkout Code') {
        checkoutCode()
    }
    
    stage('üì¶ Install Dependencies') {
        installDependencies(config)
    }
    
    stage('üèóÔ∏è Build Application') {
        buildApplication(config)
    }
    
    stage('üê≥ Build Docker Image') {
        buildDockerImage(config, derived)
    }
    
    stage('üì§ Push to Docker Hub') {
        pushToDockerHub(config, derived)
    }
    
    stage('üìã Prepare Deployment') {
        prepareDeployment(config, derived)
    }
    
    stage('üöÄ Deploy to Swarm') {
        deployToSwarm(config, derived)
    }
    
    stage('üîç Verify Deployment') {
        verifyDeployment(config, derived)
    }
    
    stage('üè• Health Check') {
        performHealthCheck(config, derived)
    }
    
    stage('üìä Final Status') {
        displayFinalStatus(config, derived)
    }
}

// ============================================
// STAGE IMPLEMENTATIONS
// ============================================

def validateGitWorkflow(config) {
    if (!config.validation.blockDirectPushes) {
        echo "‚ö†Ô∏è Direct push validation is disabled"
        return
    }
    
    echo "Validating Git workflow"
    
    // First, checkout the code to get git info
    checkout scm
    
    def isMerge = sh(
        script: "git rev-parse HEAD^2 >/dev/null 2>&1 && echo true || echo false",
        returnStdout: true
    ).trim()

    def committer = sh(
        script: "git log -1 --pretty=format:%cn",
        returnStdout: true
    ).trim()

    if (isMerge == "false") {
        error """
        ‚ùå DIRECT PUSH TO MAIN BLOCKED
        
        Commit ${env.GIT_COMMIT} by ${committer} is a direct commit to main.
        
        REQUIRED WORKFLOW:
        1. Create feature branch: git checkout -b feature/your-feature
        2. Make changes and commit
        3. Create Pull Request to main
        4. Get code review approval
        5. Merge via PR
        """
    }
    
    echo "‚úÖ Git workflow validated"
}

def environmentCheck(config) {
    echo "Checking environment requirements"
    
    // Check required tools
    config.validation.requiredTools.each { tool ->
        sh """
            if command -v ${tool} >/dev/null 2>&1; then
                echo "‚úÖ ${tool}: \$(which ${tool})"
            else
                echo "‚ùå ${tool}: Not found"
                exit 1
            fi
        """
    }
    
    // Check disk space
    sh """
        FREE_SPACE=\$(df -h . | awk 'NR==2 {print \$4}' | sed 's/G//')
        echo "üíæ Free disk space: \${FREE_SPACE}G"
        
        if [ \$FREE_SPACE -lt ${config.validation.minDiskSpace} ]; then
            echo "‚ö†Ô∏è  Low disk space (< ${config.validation.minDiskSpace}G)"
        fi
    """
    
    echo "‚úÖ Environment check passed"
}

def checkoutCode() {
    echo "Checking out source code"
    checkout scm
    sh 'git log --oneline -1'
}

def installDependencies(config) {
    echo "Installing dependencies: ${config.application.installCommand}"
    sh config.application.installCommand
    echo "‚úÖ Dependencies installed"
}

def buildApplication(config) {
    echo "Building application: ${config.application.buildCommand}"
    sh config.application.buildCommand
    echo "‚úÖ Application built"
}

def buildDockerImage(config, derived) {
    echo "Building Docker image"
    sh """
        docker build -t ${derived.imageTag} .
        docker tag ${derived.imageTag} ${derived.latestTag}
    """
    echo "‚úÖ Docker image built: ${derived.imageTag}"
}

def pushToDockerHub(config, derived) {
    echo "Pushing to Docker Hub"
    
    withCredentials([usernamePassword(
        credentialsId: config.docker.credentialsId,
        usernameVariable: 'DOCKER_USER',
        passwordVariable: 'DOCKER_PASS'
    )]) {
        sh """
            docker login -u \${DOCKER_USER} -p \${DOCKER_PASS}
            docker push ${derived.imageTag}
            docker push ${derived.latestTag}
            docker logout
        """
    }
    
    echo "‚úÖ Images pushed to Docker Hub"
}

def prepareDeployment(config, derived) {
    echo "Preparing deployment configuration"
    
    def composeContent = """
        version: '3.8'
        services:
          ${config.deployment.composeServiceName}:
            image: ${derived.imageTag}
            ports:
              - "${config.deployment.hostPort}:${config.application.containerPort}"
            deploy:
              replicas: ${config.deployment.replicas}
              restart_policy:
                condition: on-failure
              update_config:
                parallelism: ${config.deployment.updateParallelism}
                delay: ${config.deployment.updateDelay}
                order: ${config.deployment.updateOrder}
    """
    
    writeFile file: config.deployment.composeFile, text: composeContent
    echo "‚úÖ Created ${config.deployment.composeFile}"
}

def deployToSwarm(config, derived) {
    echo "Deploying to Docker Swarm"
    
    // Ensure Swarm is active
    def swarmStatus = sh(
        script: "docker info --format '{{.Swarm.LocalNodeState}}' 2>/dev/null || echo 'inactive'",
        returnStdout: true
    ).trim()
    
    if (swarmStatus != 'active') {
        echo "Initializing Docker Swarm"
        sh "docker swarm init --advertise-addr 127.0.0.1 2>/dev/null || true"
        sleep 3
    }
    
    // Deploy stack
    withCredentials([usernamePassword(
        credentialsId: config.docker.credentialsId,
        usernameVariable: 'DOCKER_USER',
        passwordVariable: 'DOCKER_PASS'
    )]) {
        sh """
            docker login -u \${DOCKER_USER} -p \${DOCKER_PASS}
            docker stack deploy -c ${config.deployment.composeFile} ${config.deployment.stackName} --with-registry-auth
            docker logout
        """
    }
    
    echo "‚úÖ Stack deployed: ${config.deployment.stackName}"
    echo "üîå Service: ${derived.swarmServiceName}"
    echo "üåê Port: ${config.deployment.hostPort}"
}

def verifyDeployment(config, derived) {
    echo "Verifying deployment"
    sleep 10
    
    // Retry verification
    def maxRetries = config.pipeline.maxRetries
    def verified = false
    
    for (int i = 0; i < maxRetries && !verified; i++) {
        try {
            sh """
                echo "üìä Deployment Status - Attempt ${i + 1}/${maxRetries}"
                echo "=================================="
                docker stack services ${config.deployment.stackName}
                
                echo ""
                echo "üìà Service Details"
                echo "=================="
                docker service inspect ${derived.swarmServiceName} --format '
Name:    {{.Spec.Name}}
Image:   {{.Spec.TaskTemplate.ContainerSpec.Image}}
Status:  {{.UpdateStatus.State}}
Replicas: {{.Spec.Mode.Replicated.Replicas}} desired
Port:    {{range .Endpoint.Ports}}{{.PublishedPort}}->{{.TargetPort}} {{end}}
                '
            """
            verified = true
        } catch (Exception e) {
            echo "‚ö†Ô∏è Verification attempt ${i + 1} failed: ${e.message}"
            if (i < maxRetries - 1) {
                sleep 5
            }
        }
    }
    
    if (!verified) {
        error "Failed to verify deployment after ${maxRetries} attempts"
    }
    
    echo "‚úÖ Deployment verified"
}

def performHealthCheck(config, derived) {
    echo "Performing health check on port ${config.deployment.hostPort}"
    
    def healthCheckPassed = false
    def maxAttempts = config.pipeline.healthCheckAttempts
    
    for (int attempt = 1; attempt <= maxAttempts; attempt++) {
        echo "Health check attempt ${attempt}/${maxAttempts}"
        
        try {
            def statusCode = sh(
                script: """
                    curl -s -o /dev/null -w '%{http_code}' \
                        --max-time 5 \
                        http://localhost:${config.deployment.hostPort}${config.application.healthCheckPath} || echo '000'
                """,
                returnStdout: true
            ).trim()
            
            if (statusCode == '200' || statusCode.startsWith('2')) {
                echo "‚úÖ Health check passed (HTTP ${statusCode})"
                healthCheckPassed = true
                break
            } else {
                echo "‚è≥ Got HTTP ${statusCode}, retrying in ${config.pipeline.healthCheckInterval}s..."
            }
        } catch (Exception e) {
            echo "‚è≥ Connection attempt ${attempt} failed: ${e.message}"
        }
        
        sleep config.pipeline.healthCheckInterval
    }
    
    if (!healthCheckPassed) {
        echo "‚ö†Ô∏è Health check inconclusive"
        sh """
            echo "üìã Checking container status..."
            docker service ps ${derived.swarmServiceName} --no-trunc || echo "Could not get service status"
            
            echo ""
            echo "üìú Recent logs:"
            docker service logs ${derived.swarmServiceName} --tail 5 2>/dev/null || echo "Could not get logs"
        """
        echo "‚ö†Ô∏è Manual verification recommended at http://localhost:${config.deployment.hostPort}"
    } else {
        echo "‚úÖ Health check completed successfully"
    }
}

def displayFinalStatus(config, derived) {
    echo "Final Deployment Status"
    echo "======================"
    
    sh """
        echo "üéØ DEPLOYMENT COMPLETE"
        echo ""
        echo "üìã Configuration"
        echo "   Application:  ${config.application.name}"
        echo "   Stack:        ${config.deployment.stackName}"
        echo "   Service:      ${derived.swarmServiceName}"
        echo "   Image:        ${derived.imageTag}"
        echo "   Port:         ${config.deployment.hostPort}"
        echo "   Build:        ${derived.buildInfo.number}"
        echo ""
        echo "üåê Access URL"
        echo "   http://localhost:${config.deployment.hostPort}"
        echo ""
        echo "üîß Management Commands"
        echo "   View logs:    docker service logs ${derived.swarmServiceName} -f"
        echo "   Check status: docker service ps ${derived.swarmServiceName}"
        echo "   Scale:        docker service scale ${derived.swarmServiceName}=3"
        echo "   Remove:       docker stack rm ${config.deployment.stackName}"
    """
    
    currentBuild.description = "${config.application.name} v${derived.buildInfo.number}"
}

// ============================================
// ERROR HANDLING & CLEANUP
// ============================================

def handleFailure(Exception e, config, derived) {
    echo """
    ‚ùå PIPELINE FAILED
    =================
    Error: ${e.message}
    
    Debug Information:
    ‚Ä¢ Service: ${derived.swarmServiceName}
    ‚Ä¢ Port: ${config.deployment.hostPort}
    ‚Ä¢ Build: ${derived.buildInfo.number}
    """
    
    // Collect debugging info
    try {
        sh """
            echo "üîç Docker Services:"
            docker service ls 2>/dev/null || echo "No services found"
            
            echo ""
            echo "üîç Stack Status:"
            docker stack ps ${config.deployment.stackName} 2>/dev/null || echo "Stack not found"
            
            echo ""
            echo "üîç Recent Logs:"
            docker service logs ${derived.swarmServiceName} --tail 10 2>/dev/null || echo "Could not get logs"
        """
    } catch (Exception ex) {
        echo "‚ö†Ô∏è Could not collect debug info: ${ex.message}"
    }
}

def cleanup(config) {
    echo "Performing cleanup"
    
    if (config.pipeline.pruneImages) {
        sh "docker image prune -f 2>/dev/null || true"
    }
    
    sh "docker logout 2>/dev/null || true"
    
    echo "‚úÖ Cleanup completed"
}

def displaySummary(result, config, derived) {
    def message = """
    ========================================
    PIPELINE ${result ?: 'COMPLETED'}
    ========================================
    """
    
    if (result == 'SUCCESS') {
        message += """
        üéâ SUCCESS
        ‚Ä¢ Application: ${config.application.name}
        ‚Ä¢ Version: ${derived.buildInfo.number}
        ‚Ä¢ Service: ${derived.swarmServiceName}
        ‚Ä¢ URL: http://localhost:${config.deployment.hostPort}
        ‚Ä¢ Build: ${derived.buildInfo.url}
        """
    } else {
        message += """
        ‚ùå FAILURE
        ‚Ä¢ Check logs for details
        ‚Ä¢ Verify port ${config.deployment.hostPort} is available
        ‚Ä¢ Check Docker Hub credentials
        ‚Ä¢ Verify network connectivity
        
        Recovery Steps:
        1. Check service: docker service ls | grep ${config.application.name}
        2. View logs: docker service logs ${derived.swarmServiceName}
        3. Manual deploy: docker stack deploy -c ${config.deployment.composeFile} ${config.deployment.stackName}
        """
    }
    
    echo message
}
